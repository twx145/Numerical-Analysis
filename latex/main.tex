% !TEX program = xelatex
% !TEX encoding = UTF-8

\documentclass[12pt, a4paper, dotinlabels]{article}
%\documentclass[zihao=-4, a4paper, UTF8]{ctexart}

% ======================================================================
% 1. 宏包设置 (Preamble)
% ======================================================================

% --- 页面与字体设置 ---
\usepackage{geometry}
\geometry{a4paper, left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm} % 设置页边距

\usepackage{fontspec} % 允许设置字体
\setmainfont{Times New Roman} % 设置英文字体
\usepackage[UTF8]{ctex} % 中文支持宏包，自动设置中文字体

% --- 设置全局中文字体方案 ---
\setCJKmainfont{SimSun}  % 设置中文主字体为宋体
\setCJKsansfont{SimHei}  % 设置中文无衬线字体为黑体

% --- 数学公式相关 ---
\usepackage{amsmath} % AMS数学宏包
\usepackage{amssymb} % AMS数学符号宏包

% --- 图形与表格相关 ---
\usepackage{graphicx} % 插入图片
\usepackage{subcaption} % 插入子图
\usepackage{caption} % 自定义图表标题
\captionsetup{labelsep=space, justification=centering, font=small} % 图表标题设置
\usepackage{subcaption} % 子图
\usepackage{booktabs} % 三线表
\usepackage{longtable} % 跨页表格
\usepackage{multirow} % 合并表格单元格

% --- 参考文献设置 (使用 biblatex 和 biber) ---
\usepackage[
backend=biber,       % 使用biber作为后端
style=gb7714-2015,   % 符合国标 GB/T 7714-2015 的参考文献样式
sorting=none         % 按引用顺序排序
]{biblatex}
\addbibresource{references.bib} % 关联参考文献数据库文件

% --- 其他常用宏包 ---
\usepackage{hyperref} % 创建超链接
\hypersetup{
	colorlinks=true,
	linkcolor=black,
	filecolor=magenta,
	urlcolor=cyan,
	pdftitle={数值分析方程的迭代解法研究报告},
	pdfpagemode=FullScreen,
}

\usepackage{fancyhdr} % 设置页眉页脚
% 样式1：'fancy' - 用于正文，带有页眉和横线
\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{\leftmark}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
% 样式2：'plainfancy' - 用于摘要、目录等前置部分，没有页眉和横线
\fancypagestyle{plainfancy}{
	\fancyhf{} % 清空页眉页脚
	\fancyfoot[C]{\thepage} % 只在页脚中间显示页码
	\renewcommand{\headrulewidth}{0pt} % 页眉线宽度为0
	\renewcommand{\footrulewidth}{0pt} % 页脚线宽度为0
}

\usepackage{titlesec} % 自定义章节标题格式
\titleformat{\section}{\Large\bfseries\sffamily}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries\sffamily}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries\sffamily}{\thesubsubsection}{1em}{}

\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}} % for \section
\renewcommand{\cftsubsecleader}{\cftdotfill{\cftdotsep}} % for \subsection
\renewcommand{\cftsubsubsecleader}{\cftdotfill{\cftdotsep}} % for \subsubsection
\renewcommand{\cftdotsep}{2.5}
\setlength{\cftbeforesecskip}{1em}  % 调整 \section 条目之前的距离
\setlength{\cftbeforesubsecskip}{0.5em} % 调整 \subsection 条目之前的距离

\usepackage{setspace}
\setlength{\cftbeforesecskip}{0pt}
\setlength{\cftbeforesubsecskip}{0pt}

% --- 代码显示宏包与样式设置 ---
\usepackage{listings}
\usepackage{xcolor} 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}
% 设置 listings 的全局样式
\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{blue},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\footnotesize\ttfamily, % 设置代码字体为等宽字体
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2,
	frame=single, % 给代码块添加边框
	rulecolor=\color{black},
	title=\lstname % 显示文件名或标题
}
\lstset{style=mystyle} % 应用全局样式

% 自定义 abstract 环境
\renewenvironment{abstract}
{\small
	\begin{center}
		{\Large\bfseries\sffamily\abstractname\vspace{1em}\vspace{0pt}}
	\end{center}
	\quotation}
{\endquotation}
\renewcommand{\contentsname}{{\sffamily\bfseries 目录}}


% ======================================================================
% 2. 文档信息
% ======================================================================

\title{数值分析方程的迭代解法研究报告}
\author{佟文轩}
\date{\today}


% ======================================================================
% 3. 文档正文开始
% ========================================================

\begin{document}
	
	% --- 详细封面页 ---
	\begin{titlepage}
		\begin{center}
			
			% 顶部可以添加校徽或学校名称
			% \includegraphics[width=4cm]{logo.png} % 如果有校徽图片
%			\vspace*{1.5cm} % 顶部留白
%			{\LARGE \bfseries 某某大学本科生毕业论文\par} % 学校和论文类型
%			\vspace{0.5cm}
%			\rule{\textwidth}{1pt} % 一条分割线
			
			\vspace*{3.5cm}
			
			% --- 论文题目 ---
			{\Huge \bfseries 数值分析上机研究报告\par}
			
			\vspace{8cm}
			
			% --- 作者、学号等详细信息 ---
			\begin{tabular}{l@{\hspace{1em}}l} % l代表左对齐，@{}中间是列间距
				姓    \quad 名： & \Large 佟文轩 \\
				\addlinespace[1em] % 增加行间距
				学    \quad 号： & \Large 1120240934 \\
				\addlinespace[1em]
				专    \quad 业： & \Large 计算机科学与技术 \\
				\addlinespace[1em]
				指导老师： & \Large 孙新 \\
			\end{tabular}
			
			\vfill % 将下面的内容推到底部
			
			% --- 日期 ---
			{\large \today\par}
			
		\end{center}
	\end{titlepage}
	
	% --- 切换到正文页码和样式 ---
	\newpage
	\pagenumbering{roman}
	\thispagestyle{plainfancy}
	
	% --- 摘要与关键词 ---
	\begin{abstract}
		
		在数值分析的第二章课程中我们学习了非线性方程的迭代解法；在第三章与第四章中我们学习了线性方程组的直接解法和迭代解法，这一类方法利用了计算机高效的计算能力，是为计算机量身定制的，不同于以往我们在学习中接触到的解析式解法和克莱姆法则。因此，本报告的目的是在计算机中实际应用上述迭代方法，以加深自己对相关知识的理解。
		
		本报告选择使用JAVA语言来进行上机实现，原因有三：其一为JAVA还提供较为方便的javafx方便将我的程序更好的可视化；其二JAVA可以将我的程序方便的转化为软件，方便他人一键安装使用；其三本学期新增JAVA选修课可以借此机会增加对JAVA语言的熟练度。
		
		在软件的子功能方程的迭代解法中，我手动编写了有关方法——牛顿法、艾特肯迭代法、单点弦截法等8种方法，其余部分借助AI完成相关内容的编写。该软件展现了方程迭代在二维坐标系和一维坐标轴上的变化，方便我们从不同的角度去观察映射对迭代行为的影响。此外，本程序记录每次迭代产生的相关数据，包括x轴坐标值、f(x)值、相邻两次迭代x轴坐标差值等内容。
		
		在软件的另一个子功能线性方程组的解法中，我编写了直接法——高斯消元法、克劳特消元法、列主元素法和全主元素法，这部分内容通过矩阵的实时变换来进行可视化；同时我编写了迭代法——雅可比迭代法、高斯赛德尔迭代法、松弛迭代法，这部分内容通过残差变化曲线图来进行迭代效率的可视化。
		
		本报告展示了不同方法的代码实现、对比了不同方法之间的差异，最后提供了一个安装程序，以便他人可以方便的使用迭代方法的演示功能。以下为我的GitHub仓库：\url{https://github.com/twx145/Numerical-Analysis}，其中记录了所有相关代码和latex\cite{knuth1984}文案。
		
		\vspace{1em} % 增加一点垂直间距
		\noindent {\heiti 关键词：} 方程迭代解法；线性方程组的数值解法；JAVA方程（组）求解软件
	\end{abstract}
	
	\newpage
	
	% --- 目录 ---
	\begin{center}
		\begin{spacing}{1.3}
			\tableofcontents % 目录生成命令
		\end{spacing}
	\end{center}
	
	\newpage
	% --- 设置正文部分的页码为阿拉伯数字, 并从1开始 ---
	\pagenumbering{arabic} % 此命令会自动将页码重置为1
	\pagestyle{fancy}
	
	% ======================================================================
	% 4. 论文正文各章节
	% ======================================================================
	
	\section{引言}
	
	非线性方程因其通常能比线性方程更好的描述事物的规律而在学习生活中很常见，但是却鲜有非线性方程可以求得解析解，因此，为计算机计算方程解而量身打造的迭代法变得很重要，迭代法通过一系列逐步逼近可以得到预期精度的解，具有高效精准的特点。
	
	线性方程组当今在深度学习大模型训练领域应用广泛，利用高效精准的方程组求解算法可以显著增加模型训练的效率和成功率。不同于线性代数中经典解法——克莱姆法则的多次矩阵运算带来的低效，方程组的直接解法为小型稠密矩阵提供了求解方案，方程组的迭代解法则给大型稀疏矩阵的求解带来了巨大的便利。
	
	本报告的核心任务包含以下三点：一是研究课内外常见的数值解法\cite{SSBDA84C6D76690EA6A8711D933DAB5349AA}；二为利用JAVA打造一个方程（组）求解可视化软件。该软件允许用户自主输入不同的方程（组）并选择不同策略来执行求解操作，此外我的软件还提供了相关的指标来分析各个迭代方法；三是通过数值实验的方法来比较不同迭代方法在收敛速度和稳定性的表现。
	
	
	
	\section{方程的迭代解法}
	
	本节着重介绍迭代法的原理，同时详细的介绍8种迭代法各自的基本思想、数学公式、算法步骤、收敛性分析与优缺点。
	
	\subsection{理论基础}
	
	这里我们先讨论一下何为压缩映射，以及压缩映射的性质，稍后再讨论压缩映射与其性质是如何帮助我们通过迭代法算出方程解的。
	
	\subsubsection{压缩映射}
	
	压缩映射是针对一个函数映射在某一个闭区间上而言的。若在一个区间内每经过一次映射变换，各个点依旧在这个区间内并且它们之间的距离都缩小，我们则称该映射在该区间是一个压缩映射。
	
	更加严谨的来说，我们有一个映射 \(g(x)\) 和一个区间 \(I = [x_1, x_2]\)。若在该区间 \(I\) 内任意两点 \(a, b\)，在经过映射后的 \(g(a)\) 和 \(g(b)\) 依旧在区间 \(I\) 内，并且距离缩小——即存在一个 \(L < 1\) 使得：
	\begin{equation}
		|g(a) - g(b)| \leq L |a - b|
	\end{equation}
	
	则我们称该映射为压缩映射。这个常数 \(L\) 被称为压缩因子。\(L < 1\) 这个条件保证了“收缩”的发生，压缩映射示例见图\ref{fig:four_pictures}。

	\begin{figure}[htbp] % 'h'ere, 't'op, 'b'ottom, 'p'age of floats
		\centering % 整体居中
		
		% --- 第一行图片 ---
		\begin{subfigure}[b]{0.48\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/ys (1).png}
			\caption{迭代0次（初始状态）}
			\label{fig:top_left}
		\end{subfigure}
		\hfill % 在两个子图之间插入一个弹性的水平空白
		\begin{subfigure}[b]{0.48\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/ys (2).png}
			\caption{迭代2次}
			\label{fig:top_right}
		\end{subfigure}
		
		% 在两行图片之间添加一些垂直间距
		\vskip\baselineskip 
		
		% --- 第二行图片 ---
		\begin{subfigure}[b]{0.48\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/ys (3).png}
			\caption{迭代4次}
			\label{fig:bottom_left}
		\end{subfigure}
		\hfill % 在两个子图之间插入一个弹性的水平空白
		\begin{subfigure}[b]{0.48\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/ys (4).png}
			\caption{迭代8次}
			\label{fig:bottom_right}
		\end{subfigure}
		
		\caption{压缩映射示意图(方程 g(x)=0.5x+2 在不同迭代次数下压缩程度)}
		\label{fig:four_pictures}
	\end{figure}
	
	\subsubsection{压缩映射的性质}
	
	一个压缩映射可以在多次迭代后将区间内的点汇集到一个称为不动点的位置。
	
	严谨的来说，我们可以构建一个压缩多次后两点间距离上界的等比数列，由于 \(L < 1\) 这个条件的存在，我们不难得知多次迭代后这个数列必将收敛于0。
	
	\subsubsection{如何判断压缩映射}
	
	根据微积分中的中值定理，我们知道对于任意的 \(x\) 和 \(y\)，在它们之间必定存在一个点 \(c\)，使得：
	\begin{equation}
		g(x) - g(y) = g'(c) \cdot (x - y)
	\end{equation}
	
	两边取绝对值得到：
	\begin{equation}
		|g(x) - g(y)| = |g'(c)| \cdot |x - y|
	\end{equation}
	
	现在将这个公式与压缩映射的定义 \(|g(x) - g(y)| \leq L |x - y|\) 我们不难发现：\(|g'(x)|\) 的大小决定了映射是压缩还是发散的。如果我们能在一个包含根的区间 \(I\) 上找到一个常数 \(L < 1\)，使得对区间 \(I\) 内所有的 \(x\)，都有 \(|g'(x)| \leq L\)，那么 \(g(x)\) 在该区间上就是一个压缩映射。
	
	
	\subsubsection{方程迭代求根}
	
	现在我们知道了一个压缩映射 \(g(x)\) 通过多次迭代可以收敛于一个不动点 \(x_0\) (\(x_0 = g(x_0)\))，那我们就可以将原始方程 \(f(x) = 0\) 变形为 \(x = g(x)\)，随后通过多次迭代算出不动点 \(x_0 = g(x_0)\)，这里 \(x_0\) 就是方程的解。
	
	\subsection{详细迭代方法}
	
	\subsubsection{普通迭代法}
	
	\noindent{\heiti 基本思想}
	
	普通迭代法的主要想法就是朴素的将方程 \(f(x) = 0\) 等价变形为 \(x = g(x)\) 从而直接求得这个新函数的不动点。选定一个初始近似值 \(x_0\) 后，通过迭代公式 \(x_{k+1} = g(x_k)\) 产生一个序列 \(x_0, x_1, x_2, \ldots\)。如果这个序列收敛于某个值 \(x_0\)，那么 \(x_0\) 就是方程的解。
	
	\vspace{1em}
	\noindent{\heiti 数学公式}
	
	普通迭代法的迭代公式为：
	\begin{equation}
			x_{k+1} = g(x_k), \quad k = 0, 1, 2, \ldots
	\end{equation}
	\vspace{1em}
	\noindent{\heiti 算法步骤}
	
		\textbf{1.} 将方程 \(f(x) = 0\) 转换为 \(x = g(x)\)。\\
		\indent\textbf{2.} 选取一个初始近似值 \(x_0\) 和一个允许误差 \(\epsilon\)。\\
		\indent\textbf{3.} 根据迭代公式 \(x_{k+1} = g(x_k)\) 计算下一个近似值。\\
		\indent\textbf{4.} 判断是否满足收敛条件 \(|x_{k+1} - x_k| < \epsilon\)。若满足，则停止迭代，\(x_{k+1}\) 即为所求解的近似根。\\
		\indent\textbf{5.} 若不满足收敛条件，则令 \(x_k = x_{k+1}\)，返回第3步继续迭代。
	
	\vspace{1em}
	\noindent{\heiti 收敛性分析}
	
	不动点迭代法的收敛性与迭代函数 \(g(x)\) 的性质密切相关。根据上述的压缩映射相关知识，我们知道只有迭代函数 \(g(x)\) 满足以下两个条件迭代过程才收敛：

		\textbf{1.} 对于任意 \(x \in [a, b]\)，都有 \(g(x) \in [a, b]\)。\\
		\indent\textbf{2.} 存在一个常数 \(0 \le L < 1\)，使得对于任意 \(x \in (a, b)\)，都有 \(|g'(x)| \le L\)。
	
	\vspace{1em}
	\noindent{\heiti 优缺点}
	
		\textbf{·} {优点}：算法简单朴素，易于理解。\\
		\indent\textbf{·}{缺点}：\\
			\indent\indent\textbf{-} 迭代函数的构造不唯一，不同的构造方式可能导致收敛性不同，甚至发散。\\
			\indent\indent\textbf{-} 收敛速度通常较慢，仅为一阶收敛。\\
			\indent\indent\textbf{-} 对初值的选取比较敏感，需要选取在根附近的初值才能保证收敛。
	
	\vspace{1em}
	\noindent{\heiti 软件示例}
	
	下图展示了我们选择原始函数\(f(x) = x^3 - x - 1\) 和迭代函数\(g(x) = \sqrt[3]{x+1}\)时的软件运行截图（详细代码见附录A）。
	
	\begin{figure}[h] 
		\centering 
		\begin{subfigure}{0.48\textwidth} 
			\centering
			\includegraphics[width=\linewidth]{pic/1.2.png}
			\caption{普通迭代法软件运行截图1} 
			\label{fig:1.1}
		\end{subfigure}
		\hfill 
		\begin{subfigure}{0.48\textwidth} 
			\centering
			\includegraphics[width=\linewidth]{pic/1.1.png} 
			\caption{普通迭代法软件运行截图2}
			\label{fig:1.2}
		\end{subfigure}
		
		\caption{普通迭代法软件运行截图}
		\label{fig:11} 
	\end{figure}
	
	\newpage
	\subsubsection{牛顿迭代法}
	
	\noindent{\heiti 基本思想}
	
	从普通迭代法的收敛性理论我们知道，迭代函数的导数绝对值越小，收敛速度就越快。牛顿法正是基于这一思想，改造迭代函数将导数的绝对值变为零以快速收敛。
	
	我们将原始方程 \(f(x)=0\) 转化为等价的不动点形式 \(x = g(x)\)。为了引入可调节的参数，我们构造一个更普遍的迭代函数：
	\begin{equation}
		g(x) = x + \alpha(x)f(x)
	\end{equation}
	
	其中 \(\alpha(x)\) 是一个待定的函数。只要 \(f(x)=0\)，这个形式就等价于 \(x=g(x)\)。由上述推理可知我们希望在根 \(x_0\) 附近有 \(|g'(x)| \approx 0\)。对 \(g(x)\) 求导可得：
	\begin{equation}
		g'(x) = 1 + \alpha'(x)f(x) + \alpha(x)f'(x)
	\end{equation}
	
	在根 \(x_0\) 附近，由于 \(f(x)\approx0\)，上式简化为：
	\begin{equation}
		g'(x) = 1 + \alpha(x)f'(x)
	\end{equation}
	
	我们令 \(g'(x) = 0\)，解得：
	\begin{equation}
		\alpha(x) = -\frac{1}{f'(x)}
	\end{equation}
	
	由此，我们选择 \(\alpha(x) = -\frac{1}{f'(x)}\) 作为我们的迭代函数，便得到了牛顿迭代法。它通过每一步都选取能让迭代函数导数趋近于零的方向，从而实现了局部二阶收敛。
	
	\vspace{1em}
	\noindent{\heiti 数学公式}
	
	我们将 \(\alpha(x_k) = -\frac{1}{f'(x_k)}\) 代入迭代公式 \(x_{k+1} = x_k + \alpha(x_k)f(x_k)\)，即可得到牛顿法的迭代公式：
	\begin{equation}
		x_{k+1} = x_k - \frac{f(x_k)}{f'(x_k)}
	\end{equation}
	
	\vspace{1em}
	\noindent{\heiti 算法步骤}
	
	\textbf{1.} 选取一个初始近似值 \(x_0\) 和一个允许误差 \(\epsilon\)。\\
	\indent\textbf{2.} 计算函数值和导数值，计算 \(f(x_k)\) 和一阶导数 \(f'(x_k)\)。\\
	\indent\textbf{3.} 根据迭代公式 \(x_{k+1} = x_k - \frac{f(x_k)}{f'(x_k)}\) 计算下一个近似值。\\
	\indent\textbf{4.} 判断是否满足收敛条件 \(|x_{k+1} - x_k| < \epsilon\)。若满足，则停止迭代，\(x_{k+1}\) 即为所求解的近似根。\\
	\indent\textbf{5.} 若不满足收敛条件，则令 \(x_k = x_{k+1}\)，返回第3步继续迭代。
	
	\vspace{1em}
	\noindent{\heiti 收敛性分析}
	
	牛顿法有局部收敛特性，且在一定情况收敛速度很快。
	
	\textbf{1.} 若\(x_0\) 为方程单根且选定的初值距离根较近则收敛阶为2。\\
	\indent\textbf{2.} 若\(x_0\) 为方程重根则收敛阶为1。\\
	\indent\textbf{3.} 迭代函数是否收敛严重依赖于初值的选择，只有初值距离根足够接近才会收敛。
	
	\vspace{1em}
	\noindent{\heiti 优缺点}
	
		\textbf{·} {优点}：\\
			\indent\indent\textbf{-} 收敛速度快，对于单根，具有二阶收敛性。\\
			\indent\indent\textbf{-} 算法简洁，迭代公式形式简单易于理解。\\
		\indent\textbf{·}{缺点}：\\
			\indent\indent\textbf{-} 初始值敏感，只有在跟附近才可能收敛到根处。\\
			\indent\indent\textbf{-} 需要计算导数，对复杂函数求导计算量大，该方法受限。
			
	\vspace{1em}
	\noindent{\heiti 软件示例}
	
	下图展示了我们选择原始函数\(f(x) = x^3 - x - 1\) 时的软件运行截图（详细代码见附录A）。
	
	\begin{figure}[h] 
		\centering 
		\begin{subfigure}{0.48\textwidth} 
			\centering
			\includegraphics[width=\linewidth]{pic/2.2.png}
			\caption{牛顿迭代法软件运行截图1} 
			\label{fig:2.1}
		\end{subfigure}
		\hfill 
		\begin{subfigure}{0.48\textwidth} 
			\centering
			\includegraphics[width=\linewidth]{pic/2.1.png} 
			\caption{牛顿迭代法软件运行截图2}
			\label{fig:2.2}
		\end{subfigure}
		
		\caption{牛顿迭代法软件运行截图}
		\label{fig:22} 
	\end{figure}
	
	\subsubsection{简化切线法}
	
	\noindent{\heiti 基本思想}
	
	牛顿法需要在每次迭代时都计算导数 \(f'(x_k)\)，当导数函数 \(f'(x)\) 的形式复杂时，会出现计算量大、耗时等问题。简化切线法因此诞生。该方法只在初始点 \(x_0\) 计算一次导数 \(f'(x_0)\)，并在后续的所有迭代中都使用这个固定的斜率来代替牛顿迭代法种变化的 \(f'(x_k)\)。
	
	\vspace{0.5em}
	\noindent{\heiti 数学公式}
	
	迭代公式为：
	\begin{equation}
		x_{k+1} = x_k - \frac{f(x_k)}{f'(x_0)}
	\end{equation}
	
	\vspace{0.5em}
	\noindent{\heiti 算法步骤}
	
	\textbf{1.} 选取一个初始近似值 \(x_0\) 和一个允许误差 \(\epsilon\)。\\
	\indent\textbf{2.} 计算一次导数值作为固定斜率 \(m = f'(x_0)\)。\\
	\indent\textbf{3.} 根据迭代公式 \(x_{k+1} = x_k - \frac{f(x_k)}{m}\) 计算下一个近似值。\\
	\indent\textbf{4.} 判断是否满足收敛条件 \(|x_{k+1} - x_k| < \epsilon\)。若满足，则停止迭代。\\
	\indent\textbf{5.} 若不满足，则令 \(x_k = x_{k+1}\)，返回第3步。
	
	\vspace{0.5em}
	\noindent{\heiti 收敛性分析}
	
	该方法线性收敛，收敛速度慢于牛顿法。当初始值 \(x_0\) 离根足够近并且在根的邻域内满足条件 \(|1 - f'(x)/f'(x_0)| < 1\)，该方法是收敛的。
	
	\vspace{0.5em}
	\noindent{\heiti 优缺点}
	
	\textbf{·} {优点}：极大地减少了计算量（只计算一次导数）。\\
	\indent\textbf{·}{缺点}：\\
	\indent\indent\textbf{-} 收敛速度从牛顿法的二阶下降到一阶，收敛速度变慢。\\
	\indent\indent\textbf{-} 对初始值的选取较为敏感。
	
	\vspace{0.5em}
	\noindent{\heiti 软件示例}
	
	下图展示了我们选择原始函数\(f(x) = x^3 - x - 1\) 时的软件运行截图。
	
	\begin{figure}[h] 
		\centering 
		\begin{subfigure}{0.42\textwidth} 
			\centering
			\includegraphics[width=\linewidth]{pic/4.2.png}
			\caption{简化切线法软件运行截图1} 
			\label{fig:4.1}
			
		\end{subfigure}
		\hfill
		\begin{subfigure}{0.42\textwidth} 
			\centering
			\includegraphics[width=\linewidth]{pic/4.1.png} 
			\caption{简化切线法软件运行截图2}
			\label{fig:4.2}
		\end{subfigure}
		
		\caption{简化切线法软件运行截图}
		\label{fig:44} 
	\end{figure}
	\newpage
	\subsubsection{修正切线法}
	
	\noindent{\heiti 基本思想}
	
	修正切线法是牛顿法和简化切线法的一种折中方案。这种方法会定期执行一次导数计算，这既避免了牛顿法多次大量的导数计算又增加了简化切线法的收敛速度，在计算效率和收敛速度上取得了平衡。
	
	\vspace{0.5em}
	\noindent{\heiti 数学公式}
	
	迭代公式为：
	\begin{equation}
		x_{k+1} = x_k - \frac{f(x_k)}{m_j}
	\end{equation}
	其中斜率 \(m_j\) 会定期更新。这里我的程序设置了一个更新间隔 \(N\)，当迭代次数 \(k\) 是 \(N\) 的倍数时才更新斜率 \(m_j = f'(x_k)\) 。
	
	\vspace{0.5em}
	\noindent{\heiti 算法步骤}
	
	\textbf{1.} 选取初始值 \(x_0\)，误差 \(\epsilon\)，以及更新间隔 \(N\)。\\
	\indent\textbf{2.} 初始化斜率 \(m = f'(x_0)\)。\\
	\indent\textbf{4.} 根据公式 \(x_{k+1} = x_k - \frac{f(x_k)}{m}\) 计算下一个近似值。\\
	\indent\textbf{5.} 判断是否满足收敛条件 \(|x_{k+1} - x_k| < \epsilon\)。若满足，则停止迭代。\\
	\indent\textbf{6.} 如果 \((k+1) \pmod N = 0\)，则更新斜率 \(m = f'(x_{k+1})\)。\\
	\indent\textbf{7.} 若不满足收敛条件，则令 \(x_k = x_{k+1}\)，返回第三步。
	
	\vspace{0.5em}
	\noindent{\heiti 收敛性分析}
	
	收敛性介于牛顿法和简化切线法之间。更新频率 \(N\) 越小，收敛速度越快，但单步计算成本也越高。
	
	\vspace{0.5em}
	\noindent{\heiti 优缺点}
	
	\textbf{·} {优点}：计算成本和收敛速度相对平衡。\\
	\indent\textbf{·}{缺点}：需要额外设定一个更新频率参数 \(N\)，选择不当会影响效率。
	
	\vspace{0.5em}
	\noindent{\heiti 软件示例}
	
	下图展示了我们选择原始函数\(f(x) = x^3 - x - 1\) 时的软件运行截图。
	
	\begin{figure}[h] 
		\centering 
		\begin{subfigure}{0.42\textwidth} 
			\centering
			\includegraphics[width=\linewidth]{pic/5.2.png}
			\caption{修正切线法软件运行截图1} 
			\label{fig:5.1}
		\end{subfigure}
		\hfill 
		\begin{subfigure}{0.42\textwidth} 
			\centering
			\includegraphics[width=\linewidth]{pic/5.1.png} 
			\caption{修正切线法软件运行截图2}
			\label{fig:5.2}
		\end{subfigure}
		
		\caption{修正切线法软件运行截图}
		\label{fig:55} 
	\end{figure}

	
	\subsubsection{牛顿下山法}
	
	\noindent{\heiti 基本思想}
	
	牛顿法非常依赖合适的初值，一旦选择不当就会不收敛，这也导致了其有局部收敛的特征。牛顿下山法通过引入一个下山因子\(\lambda\) 来扩大收敛范围。下山法强制要求每次迭代都必须满足“下山”条件——即 \(|f(x_{k+1})| < |f(x_k)|\)。如果标准的牛顿步长（\(\lambda=1\)）不满足此条件，就缩小步长（将 \(\lambda\) 减半）再尝试，直到满足下山条件为止。
	
	\vspace{0.5em}
	\noindent{\heiti 数学公式}
	
	迭代公式为：
	\begin{equation}
		x_{k+1} = x_k - \lambda \frac{f(x_k)}{f'(x_k)}
	\end{equation}
	
	
	\vspace{0.5em}
	\noindent{\heiti 算法步骤}
	
	\textbf{1.} 选取初始值 \(x_0\) 和误差 \(\epsilon\)。\\
	\indent\textbf{2.} 计算牛顿步 \(d_k = \frac{f(x_k)}{f'(x_k)}\)。\\
	\indent\textbf{3.} 初始化下山因子 \(\lambda = 1\)。\\
	\indent\textbf{4.} 计算候选点 \(x_{next} = x_k - \lambda d_k\)。\\
	\indent\textbf{5.} 判断是否满足下山条件 \(|f(x_{next})| < |f(x_k)|\)。\\
	\indent\textbf{6.} 若不满足，则 \(\lambda = \lambda / 2\)，返回第4步。若 \(\lambda\) 过小则认为方法失败。\\
	\indent\textbf{7.} 若满足，则接受该点，令 \(x_{k+1} = x_{next}\)。\\
	\indent\textbf{8.} 判断是否满足收敛条件 \(|x_{k+1} - x_k| < \epsilon\)，若满足则停止迭代否则返回第2步。
	
	\vspace{0.5em}
	\noindent{\heiti 收敛性分析}
	
	下山法相比牛顿法能够更大范围的收敛。
	
	\vspace{0.5em}
	\noindent{\heiti 优缺点}
	
	\textbf{·} {优点}：相比牛顿法扩大了收敛域，对初值选择不那么敏感。\\
	\indent\textbf{·}{缺点}：算法更复杂，增加了单次迭代的计算量。
	
	
	
	\vspace{0.5em}
	\noindent{\heiti 软件示例}
	
	下图展示了我们选择原始函数\(f(x) = x^3 - x - 1\) 时的软件运行截图。
	
	\begin{figure}[h] 
		\centering 
		\begin{subfigure}{0.42\textwidth} 
			\centering
			\includegraphics[width=\linewidth]{pic/6.2.png}
			\caption{牛顿下山法软件运行截图1} 
			\label{fig:6.1}
		\end{subfigure}
		\hfill 
		\begin{subfigure}{0.42\textwidth} 
			\centering
			\includegraphics[width=\linewidth]{pic/6.1.png} 
			\caption{牛顿下山法软件运行截图2}
			\label{fig:6.2}
		\end{subfigure}
		
		\caption{牛顿下山法软件运行截图}
		\label{fig:66} 
	\end{figure}
	
	
	
	\subsubsection{单点弦截法}
	
	\noindent{\heiti 基本思想}
	
	该方法是牛顿法的另一种近似，它使用一个固定点 \((x_0, f(x_0))\) 和当前迭代点 \((x_k, f(x_k))\) 连接形成的割线与x轴的交点，来作为下一个近似根 \(x_{k+1}\)。这等价于在牛顿法公式中用差商 \(\frac{f(x_k) - f(x_0)}{x_k - x_0}\) 来近似导数 \(f'(x_k)\)。
	
	\vspace{0.5em}
	\noindent{\heiti 数学公式}
	
	迭代公式为：
	\begin{equation}
		x_{k+1} = x_k - \frac{f(x_k)(x_k - x_0)}{f(x_k) - f(x_0)}
	\end{equation}
	
	\vspace{0.5em}
	\noindent{\heiti 算法步骤}
	
	\textbf{1.} 选取一个固定点 \(x_0\) 和一个初始迭代点 \(x_1\)，以及误差 \(\epsilon\)。\\
	\indent\textbf{2.} 计算并存储 \(f(x_0)\)。\\
	\indent\textbf{3.} 对于 \(k = 1, 2, \ldots\)，根据上述公式计算下一个近似值 \(x_{k+1}\)。\\
	\indent\textbf{4.} 判断是否满足收敛条件 \(|x_{k+1} - x_k| < \epsilon\)。\\
	\indent\textbf{5.} 若不满足，则令 \(x_k = x_{k+1}\)，返回第3步。
	
	\vspace{0.5em}
	\noindent{\heiti 收敛性分析}
	
	该方法线性收敛，收敛速度通常慢于牛顿法。
	
	\vspace{0.5em}
	\noindent{\heiti 优缺点}
	
	\textbf{·} {优点}：无需计算导数。\\
	\indent\textbf{·}{缺点}：\\
	\indent\indent\textbf{-} 收敛速度为一阶，较慢。
	
	
	\vspace{0.5em}
	\noindent{\heiti 软件示例}
	
	下图展示了我们选择原始函数\(f(x) = x^3 - x - 1\) 时的软件运行截图（详细代码见附录A）。
	
	\begin{figure}[h] 
		\centering 
		\begin{subfigure}{0.42\textwidth} 
			\centering
			\includegraphics[width=\linewidth]{pic/7.2.png}
			\caption{单点弦截法软件运行截图1} 
			\label{fig:7.1}
		\end{subfigure}
		\hfill 
		\begin{subfigure}{0.42\textwidth} 
			\centering
			\includegraphics[width=\linewidth]{pic/7.1.png} 
			\caption{单点弦截法软件运行截图2}
			\label{fig:7.2}
		\end{subfigure}
		
		\caption{单点弦截法软件运行截图}
		\label{fig:77} 
	\end{figure}
	
	
	\subsubsection{双点弦截法}
	
	\noindent{\heiti 基本思想}
	
	双点弦截法是单点弦截法的一个改进，该方法使用最近的两个迭代点 \((x_{k-1}, f(x_{k-1}))\) 和 \((x_k, f(x_k))\) 来构造一条割线，并用该割线与x轴的交点作为新的近似根 \(x_{k+1}\)。
	
	\vspace{1em}
	\noindent{\heiti 数学公式}
	
	迭代公式为：
	\begin{equation}
		x_{k+1} = x_k - \frac{f(x_k)(x_k - x_{k-1})}{f(x_k) - f(x_{k-1})}
	\end{equation}
	
	\vspace{1em}
	\noindent{\heiti 算法步骤}
	
	\textbf{1.} 选取两个初始近似值 \(x_0, x_1\) 和允许误差 \(\epsilon\)。\\
	\indent\textbf{2.} 对于 \(k = 1, 2, \ldots\)，根据迭代公式计算 \(x_{k+1}\)。\\
	\indent\textbf{3.} 判断是否满足收敛条件 \(|x_{k+1} - x_k| < \epsilon\)。\\
	\indent\textbf{4.} 若不满足，则更新迭代点：令 \(x_{k-1} = x_k\)，\(x_k = x_{k+1}\)，然后返回第2步。
	
	\vspace{1em}
	\noindent{\heiti 收敛性分析}
	
	该方法具有超线性收敛性，收敛阶约为1.618。其收敛速度快于线性收敛方法，但慢于牛顿法的二阶收敛。
	
	\vspace{1em}
	\noindent{\heiti 优缺点}
	
	\textbf{·} {优点}：无需计算导数，同时保持了较快的收敛速度。\\
	\indent\textbf{·}{缺点}：与牛顿法一样是局部收敛的，不能保证对任意初值都收敛。
	
	
	
	\vspace{1em}
	\noindent{\heiti 软件示例}
	
	下图展示了我们选择原始函数\(f(x) = x^3 - x - 1\) 和迭代函数\(g(x) = \sqrt[3]{x+1}\)时的软件运行截图（详细代码见附录A）。
	
	\begin{figure}[h] 
		\centering 
		\begin{subfigure}{0.48\textwidth} 
			\centering
			\includegraphics[width=\linewidth]{pic/8.2.png}
			\caption{双点弦截法软件运行截图1} 
			\label{fig:8.1}
		\end{subfigure}
		\hfill 
		\begin{subfigure}{0.48\textwidth} 
			\centering
			\includegraphics[width=\linewidth]{pic/8.1.png} 
			\caption{双点弦截法软件运行截图2}
			\label{fig:8.2}
		\end{subfigure}
		
		\caption{双点弦截法软件运行截图}
		\label{fig:88} 
	\end{figure}
	
	\subsubsection{艾特肯迭代法}
	
	\noindent{\heiti 基本思想}
	
	艾特肯法可以看作是双点弦截法的一种变形，艾特肯法利用由不动点迭代 \(x_{k+1} = g(x_k)\) 产生的一系列点来执行双点弦截法。双点弦截法的迭代公式是利用两个点 \((x_k, f(x_k))\) 和 \((x_{k+1}, f(x_{k+1}))\) 构造割线来求根：
	\begin{equation}
		x_{new} = x_{k+1} - \frac{f(x_{k+1})(x_{k+1} - x_k)}{f(x_{k+1}) - f(x_k)}
	\end{equation}
	将\(x_k\)、\(x_{k+1}\)两个点代入函数 \(f(x) = x - g(x)\)，可得：
	\begin{equation}
		\begin{aligned}
		f(x_k) = x_k - g(x_k) = x_k - x_{k+1} \\
		f(x_{k+1}) = x_{k+1} - g(x_{k+1}) = x_{k+1} - x_{k+2}
	\end{aligned}
	\end{equation}
	现在，我们将上述结果代回双点弦截法的公式中，求出的 \(x_{new}\) 即为加速后的新迭代值 \(\hat{x}_k\):
	\begin{equation}
		\hat{x}_k = x_{k+1} - \frac{(x_{k+1} - x_{k+2})(x_{k+1} - x_k)}{(x_{k+1} - x_{k+2}) - (x_k - x_{k+1})}
	\end{equation}
	对上式分母进行化简：\((x_{k+1} - x_{k+2}) - (x_k - x_{k+1}) = -(x_{k+2} - 2x_{k+1} + x_k)\)。随后我们对整个表达式进行代数变换：
	\begin{equation}
		\begin{split}
		\hat{x}_k &= \frac{x_{k+1}((2x_{k+1} - x_k - x_{k+2}) - (x_{k+1} - x_{k+2})) - x_k(x_{k+1}-x_{k+2})}{2x_{k+1} - x_k - x_{k+2}} \\
		&= \frac{x_k x_{k+2} - x_{k+1}^2}{x_{k+2} - 2x_{k+1} + x_k} \\
		&= \frac{x_k(x_{k+2} - 2x_{k+1} + x_k) - (x_k^2 - 2x_k x_{k+1} + x_{k+1}^2)}{x_{k+2} - 2x_{k+1} + x_k} \\
		&= x_k - \frac{(x_{k+1} - x_k)^2}{x_{k+2} - 2x_{k+1} + x_k}
	\end{split}
	\end{equation}
	最终得到的这个公式就是艾特肯加速法的标准形式。它利用基础迭代产生的连续三点（\(x_k, x_{k+1}, x_{k+2}\)）来构造一个收敛更快的迭代值。
	
	\vspace{1em}
	\noindent{\heiti 数学公式}
	
	给定一个由基础迭代 \(x_{i+1}=g(x_i)\) 产生的序列，艾特肯加速序列 \(\{\hat{x}_k\}\) 的计算公式为：
	\begin{equation}
		\hat{x}_k = x_k - \frac{(x_{k+1} - x_k)^2}{x_{k+2} - 2x_{k+1} + x_k}
	\end{equation}
	
	\vspace{1em}
	\noindent{\heiti 算法步骤}
	
	\textbf{1.} 选取初始值 \(x_0\) 和误差 \(\epsilon\)。\\
	\indent\textbf{2.} 使用基础迭代公式 \(x_{i+1}=g(x_i)\) 计算两步：\(x_1 = g(x_0)\)，\(x_2 = g(x_1)\)。\\
	\indent\textbf{3.} 使用艾特肯公式计算加速后的值 \(\hat{x}_0\)。\\
	\indent\textbf{4.} 判断是否满足收敛条件 \(|\hat{x}_0 - x_0| < \epsilon\)。\\
	\indent\textbf{5.} 若不满足，则令 \(x_0 = \hat{x}_0\)，返回第2步继续迭代。
	
	\vspace{1em}
	\noindent{\heiti 收敛性分析}
	
	如果原始的不动点迭代法是线性收敛的，那么经过艾特肯法加速后形成的序列通常具有二阶收敛性。
	
	\vspace{1em}
	\noindent{\heiti 优缺点}
	
	\textbf{·} {优点}：显著提高线性收敛迭代法的收敛速度。\\
	\indent\textbf{·}{缺点}：\\
	\indent\indent\textbf{-} 每次迭代的计算复杂性增加。\\
	\indent\indent\textbf{-} 分母 \(x_{k+2} - 2x_{k+1} + x_k\) 接近于零时会出现数值不稳定问题。
	
	
		\vspace{1em}
	\noindent{\heiti 软件示例}
	
	下图展示了我们选择原始函数\(f(x) = x^3 - x - 1\) 和迭代函数\(g(x) = \sqrt[3]{x+1}\)时的软件运行截图（详细代码见附录A）。
	
	\begin{figure}[h] 
		\centering 
		\begin{subfigure}{0.48\textwidth} 
			\centering
			\includegraphics[width=\linewidth]{pic/3.2.png}
			\caption{艾特肯法软件运行截图1} 
			\label{fig:3.1}
		\end{subfigure}
		\hfill 
		\begin{subfigure}{0.48\textwidth} 
			\centering
			\includegraphics[width=\linewidth]{pic/3.1.png} 
			\caption{艾特肯法软件运行截图2}
			\label{fig:3.2}
		\end{subfigure}
		
		\caption{艾特肯法软件运行截图}
		\label{fig:33} 
	\end{figure}
	
	\newpage
	\section{线性方程组的直接解法}
	
	\subsection{消元法综述}
	
	\subsubsection{消元法介绍}
	
	消元法是将方程组中的一方程的未知数用含有另一未知数的代数式表示，并将其带入到另一方程中，这就消去了一未知数，得到一解；或将方程组中的一方程倍乘某个常数加到另外一方程中去，也可达到消去一未知数的目的。
	
	更本质的来看，消元法通过一系列的初等行变换，将线性方程组的增广矩阵逐步转化为一个更容易求解的等价矩阵，然后通过回代求解出未知数。
	
	\begin{equation} \label{eq:gauss_elimination}
		\mathbf{A} =
		\left[
		\begin{array}{ccc}
			a_{11} & a_{12} & a_{13}  \\
			a_{21} & a_{22} & a_{23}  \\
			a_{31} & a_{32} & a_{33} 
		\end{array}
		\right]
		\quad \xrightarrow{\text{高斯消元}} \quad
		\mathbf{U} =
		\left[
		\begin{array}{ccc}
			u_{11} & u_{12} & u_{13}  \\
			0 & u_{22} & u_{23}  \\
			0 & 0 & u_{33} 
		\end{array}
		\right]
	\end{equation}
	
	\subsubsection{消元法核心理论}
	
	\textbf{·} {两方程互换，解不变}\\
	\indent\textbf{·} {一方程乘以非零数 \(k\) 解不变}\\
	\indent\textbf{·} {一方程乘以数 \(k\) 加上另一方程，解不变}
	
	
	\subsubsection{消元法步骤}
	
	\textbf{·} {\textbf{消元}}\\
	\indent\indent\textbf{-} 将线性方程组写成增广矩阵的形式。\\
	\indent\indent\textbf{-} 通过一系列的初等行变换(在上文中提及，教材中采用l作为每一行需要除的分母，以此完成行变换)，从第一列开始，逐列将主元下方的元素变为零。\\
	\indent\indent\textbf{-}重复执行第二步直到矩阵变为上三角矩阵。
	
	\indent\textbf{·} {\textbf{回代}}\\
	\indent\indent\textbf{-} 从阶梯形矩阵的最后一行开始（该行可以直接求解）。将求得的解代入上一行，解出另一个未知数。\\
	\indent\indent\textbf{-}依次向上回代，直到求出所有未知数的解。
	
	\subsubsection{优缺点}
	
	\indent\textbf{·}{优点}：对于任何有唯一解或有无穷多解的线性方程组，理论上总能求得其精确解。\\
	\indent\textbf{·}{缺点}：\\
	\indent\indent\textbf{-} 计算量大，O(n³) 级别。\\
	\indent\indent\textbf{-} 舍入误差会出现累积并影响精度。

	\subsection{详细消元法}
	
	
	\subsubsection{高斯消元法}
	
	\noindent{\heiti 介绍}
	
	高斯消元法在每次消元的时候本行不做处理，即当前行保持原始状态，不会同下面即将要说的克劳特消元法一样进行对角元归一。
	
	\vspace{0.5em}
	\noindent{\heiti 矩阵变换公式}
	\begin{equation}
		[A|\mathbf{b}] =
		\left[
		\begin{array}{ccc|c}
			a_{11} & a_{12} & a_{13} & b_1 \\
			a_{21} & a_{22} & a_{23} & b_2 \\
			a_{31} & a_{32} & a_{33} & b_3 
		\end{array}
		\right]
		\quad \xrightarrow{\text{正向消元}} \quad
		[U|\mathbf{z}] =
		\left[
		\begin{array}{ccc|c}
			u_{11} & u_{12} & u_{13} & z_1 \\
			0 & u_{22} & u_{23} & z_2 \\
			0 & 0 & u_{33} & z_3
		\end{array}
		\right]
	\end{equation}
	
	\noindent{\heiti 收敛性}
	
	\indent\textbf{-} 在没有舍入误差且对角元不为0的理想情况下，高斯消元法总能通过有限步运算得到精确解。\\
	\indent\textbf{-} 对角线元素为0或绝对值很小时，会导致计算产生巨大的舍入误差。
	
	\vspace{0.5em}
	\noindent{\heiti 程序运行截图}
	
	下图为程序在利用高斯消元法求解线性方程组时的截图，详细代码见附录B。
	
	\begin{figure}[htbp] % 'h'ere, 't'op, 'b'ottom, 'p'age of floats
		\centering % 整体居中
		
		% --- 第一行图片 ---
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/gs (4).png}
		\end{subfigure}
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/gs (1).png}
		\end{subfigure}
		
		
		% --- 第二行图片 ---
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/gs (2).png}
		\end{subfigure}
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/gs (3).png}
		\end{subfigure}
		
		\caption{高斯消元法程序运行截图}
		\label{fig:gs}
	\end{figure}
	
	
	\subsubsection{克劳特消元法}
	
	\noindent{\heiti 介绍}
	
	克劳特消元法在每次进行消元的时候会首先将本行的对角元素进行除法，使得对角元素值为1。这样在得到上三角矩阵后方便进行回代操作。
	
	\vspace{0.5em}
	\noindent{\heiti 矩阵变换公式}
	
	\begin{equation}
		[A|\mathbf{b}] =
		\left[
		\begin{array}{ccc|c}
			a_{11} & a_{12} & a_{13} & b_1 \\
			a_{21} & a_{22} & a_{23} & b_2 \\
			a_{31} & a_{32} & a_{33} & b_3 
		\end{array}
		\right]
		\quad \xrightarrow{\text{正向消元}} \quad
		[U|\mathbf{z}] =
		\left[
		\begin{array}{ccc|c}
			1 & u_{12} & u_{13} & z_1 \\
			0 & 1 & u_{23} & z_2 \\
			0 & 0 & 1 & z_3
		\end{array}
		\right]
	\end{equation}
	
	\vspace{0.5em}
	\noindent{\heiti 收敛性}
	
	\indent\textbf{-} 与高斯消元法类似，克劳特法同样存在数值不稳定的问题。
	
	\vspace{0.5em}
	\noindent{\heiti 程序运行截图}
	
	下图为程序在利用克劳特消元法求解线性方程组时的截图，详细代码见附录B。
	
	\begin{figure}[htbp] % 'h'ere, 't'op, 'b'ottom, 'p'age of floats
		\centering % 整体居中
		
		% --- 第一行图片 ---
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/klt (1).png}
		\end{subfigure}
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/klt (2).png}
		\end{subfigure}
		
		
		% --- 第二行图片 ---
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/klt (3).png}
		\end{subfigure}
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/klt (4).png}
		\end{subfigure}
		
		\caption{克劳特消元法程序运行截图}
		\label{fig:klt}
	\end{figure}
	
	\newpage
	\subsubsection{高斯列主元素消元法}
	
	\noindent{\heiti 介绍}
	
	该方法总体思路与高斯消元法一致，只是在对每行处理的时候都会遍历该行对角元素所在的列并把找到的最大元素所在的行与当前行进行交换，保证当前行对角元素最大。
	
	\vspace{0.5em}
	\noindent{\heiti 矩阵变换公式}
	
	\begin{equation}
		A\mathbf{x}=\mathbf{b} \quad \xrightarrow{\text{行交换}} \quad PA\mathbf{x}=P\mathbf{b} \quad \xrightarrow{\text{消元}} \quad 
		[PU|P\mathbf{z}] =
		\left[
		\begin{array}{ccc|c}
			u_{11} & u_{12} & u_{13} & z_1 \\
			0 & u_{22} & u_{23} & z_2 \\
			0 & 0 & u_{33} & z_3
		\end{array}
		\right]
	\end{equation}
	
	\vspace{0.5em}
	\noindent{\heiti 收敛性}
	
	\textbf{-} 通过选取较大的主元，可以有效避免除以一个很小的数，从而抑制舍入误差的增长。\\
	\indent\textbf{-} 只要矩阵是非奇异的，列主元法即可求出结果。\\
	\indent\textbf{-} 这是目前求解小型稠密线性方程组最常用、最稳健的方法。
	
	\vspace{0.5em}
	\noindent{\heiti 程序运行截图}
	
	下图为程序在利用列主元素消元法求解线性方程组时的截图，详细代码见附录B。
	
	\begin{figure}[htbp] % 'h'ere, 't'op, 'b'ottom, 'p'age of floats
		\centering % 整体居中
		
		% --- 第一行图片 ---
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/gsl (1).png}
		\end{subfigure}
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/gsl (2).png}
		\end{subfigure}
		
		
		% --- 第二行图片 ---
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/gsl (3).png}
		\end{subfigure}
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/gsl (4).png}
		\end{subfigure}
		
		\caption{高斯列主元消元法程序运行截图}
		\label{fig:gsl}
	\end{figure}
	
	\newpage
	\subsubsection{高斯全主元素消元法}
	
	\noindent{\heiti 介绍}
	
	该方法总体思路与高斯消元法一致，只是在对每行处理的时候都会遍历未处理的整个矩阵元素并把找到的最大元素所在的位置通过行交换与列交换换到当前处理的对角元处，保证当前行对角元素全局最大。
	
	\vspace{0.5em}
	\noindent{\heiti 矩阵变换公式}
	
	\begin{equation}
		A\mathbf{x}=\mathbf{b} \quad \xrightarrow{\text{行列交换}} \quad PQA\mathbf{x}=P\mathbf{b} \quad \xrightarrow{\text{消元}} \quad 
		[PQU|P\mathbf{z}] =
		\left[
		\begin{array}{ccc|c}
			u_{11} & u_{12} & u_{13} & z_1 \\
			0 & u_{22} & u_{23} & z_2 \\
			0 & 0 & u_{33} & z_3
		\end{array}
		\right]
	\end{equation}
	
	\vspace{0.5em}
	\noindent{\heiti 收敛性}
	
	\textbf{-} 在所有高斯消元法的变种中，全主元法对舍入误差的控制效果最好。\\
	\indent\textbf{-} 因为全主元素法需要多次寻找全局最大值，其搜索开销远大于列主元法。
	
	\vspace{0.5em}
	\noindent{\heiti 程序运行截图}
	
	下图为程序在利用全主元素消元法求解线性方程组时的截图，详细代码见附录B。
	
	\begin{figure}[htbp] % 'h'ere, 't'op, 'b'ottom, 'p'age of floats
		\centering % 整体居中
		
		% --- 第一行图片 ---
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/gsq (1).png}
		\end{subfigure}
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/gsq (2).png}
		\end{subfigure}
		
		
		% --- 第二行图片 ---
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/gsq (3).png}
		\end{subfigure}
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/gsq (4).png}
		\end{subfigure}
		
		\caption{高斯全主元素消元法程序运行截图}
		\label{fig:gsq}
	\end{figure}
	
	\newpage
	
	\section{线性方程组的迭代解法}
	
	\subsection{线性方程组的迭代法综述}
	
	\subsubsection{线性方程组的迭代法介绍}
	
	迭代法从一个初始的近似解出发，通过迭代公式反复计算，逐步逼近方程组精确解。这里面确保收敛的判定依据依旧是上文在方程的迭代解法中提到的压缩映射，只要一个矩阵的谱半径小于1就可以保证方法收敛。这里的谱半径衡量的是矩阵映射变换完成后各个维度的变化最大值，只要该值小于1就表明该矩阵对于所有维度的映射都是压缩的，也就说明空间内的所有点都在向一个点靠近。
	
	\begin{equation} \label{eq:iteration_step}
		\mathbf{x}^{(k)} =
		\begin{pmatrix}
			x_1^{(k)} \\
			x_2^{(k)} \\
			\vdots \\
			x_n^{(k)}
		\end{pmatrix}
		\quad \xrightarrow{\text{迭代公式 } \mathbf{x}^{(k+1)} = \mathbf{B}\mathbf{x}^{(k)} + \mathbf{f}} \quad
		\mathbf{x}^{(k+1)} =
		\begin{pmatrix}
			x_1^{(k+1)} \\
			x_2^{(k+1)} \\
			\vdots \\
			x_n^{(k+1)}
		\end{pmatrix}
	\end{equation}
	
	\subsubsection{消元法步骤}
	
	\textbf{·} {\textbf{构造迭代格式：}}将原方程组 \(Ax = b\) 变形为一个等价的形式 \(x = Bx + f\)，其中 \(B\) 称为迭代矩阵。\\	
	\indent\textbf{·} {\textbf{选取初始向量：}}选择一个向量并从此作为迭代的起点。\\
	\indent\textbf{·} {\textbf{进行迭代：}}根据迭代公式 \(x(k+1) = Bx(k) + f\)，从 \(x(0)\) 开始，依次计算 \(x(1)\), \(x(2)\), \(x(3)\), ...\\
	\indent\textbf{·} {\textbf{判断收敛：}}每次迭代后检查是否满足收敛条件并选择停机或者继续执行第三步。\\
	
	\subsubsection{优缺点}
	
	\indent\textbf{·}{优点}：\\
	\indent\indent\textbf{-} 计算量小，迭代的计算量远小于直接法。\\
	\indent\indent\textbf{-} 舍入误差不会累积。\\
	\indent\textbf{·}{缺点}：\\
	\indent\indent\textbf{-} 不保证收敛,收敛性与迭代矩阵 \( B\) 的性质密切相关。\\
	\indent\indent\textbf{-} 得到的是近似解，而非理论上的精确解。
	
	
	\subsection{详细迭代方法}
	
	\subsubsection{雅可比迭代法}
	
	\noindent{\heiti 介绍}
	
	雅可比迭代法是一种基本的迭代方法。它的思想很类似前文讲到的方程的迭代解法，在每次计算新的向量\(x_{k+1}\)过程中，它会利用上一次的迭代结果\(x_{k}\),并将这个向量输入矩阵进行映射。由于各个分量的计算是相互独立的，因此该方法非常适合并行计算。
	
	\vspace{0.5em}
	\noindent{\heiti 矩阵迭代公式}
	
	\indent\textbf{-} {\textbf{矩阵形式}}: 
	\begin{equation}
		\mathbf{x}^{(k+1)} = -\mathbf{D}^{-1}(\mathbf{L} + \mathbf{U})\mathbf{x}^{(k)} + \mathbf{D}^{-1}\mathbf{b}
	\end{equation}
	\indent\textbf{-} {\textbf{分量形式}}:
	\begin{equation}
		x_i^{(k+1)} = \frac{1}{a_{ii}} \left( b_i - \sum_{j \neq i} a_{ij}x_j^{(k)} \right), \quad i=1, 2, \dots, n
	\end{equation}
	
	\noindent{\heiti 收敛性}
	
	\indent\textbf{-} {\textbf{充要条件}}: 迭代法收敛的充要条件是迭代矩阵的谱半径小于1。对于雅可比法，即 $\rho(\mathbf{B}_J) < 1$，其中 $\mathbf{B}_J = -\mathbf{D}^{-1}(\mathbf{L} + \mathbf{U})$。 \\
	\indent\textbf{-} {\textbf{充分条件}}: 如果系数矩阵 A 是严格对角占优矩阵，则雅可比迭代法必定收敛。\\
	\indent\textbf{-} {\textbf{充分条件}}: 如果系数矩阵 A 是对角占优矩阵且不可约，则雅可比迭代法必定收敛。\\
	\indent\textbf{-} {\textbf{充分条件}}: 如果迭代矩阵 $\mathbf{B}_J$ 的范数小于1则雅可比迭代法必定收敛。
	
	\vspace{0.5em}
	\noindent{\heiti 程序运行截图}
	
	下图为程序在利用雅克比迭代法求解线性方程组时的截图，
	\begin{figure}[h] % 'h'ere, 't'op, 'b'ottom, 'p'age of floats
		\centering % 整体居中
		
		% --- 第一行图片 ---
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/ykb (1).png}
		\end{subfigure}
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/ykb (2).png}
		\end{subfigure}
		
		
		% --- 第二行图片 ---
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/ykb (3).png}
		\end{subfigure}
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/ykb (4).png}
		\end{subfigure}
		
		\caption{雅可比迭代法程序运行截图}
		\label{fig:ykb}
	\end{figure}
	
	\subsubsection{高斯-赛德尔迭代法}
	
	\noindent{\heiti 介绍}
	
	高斯-赛德尔法是雅可比法的一种改进型。它在计算第 $k+1$ 次迭代的第 $i$ 个分量 $x_i^{(k+1)}$ 时，会立即使用在同一次迭代中已经计算出的新分量 $x_1^{(k+1)}, \dots, x_{i-1}^{(k+1)}$。这种策略使得它通常比雅可比法收敛得更快，但也因为计算存在依赖关系所以不适合并行处理。
	
	\vspace{0.5em}
	\noindent{\heiti 矩阵迭代公式}

	\indent\textbf{-} {\textbf{矩阵形式}}:
	\begin{equation}
		\mathbf{x}^{(k+1)} = -(\mathbf{D} + \mathbf{L})^{-1}\mathbf{U}\mathbf{x}^{(k)} + (\mathbf{D} + \mathbf{L})^{-1}\mathbf{b}
	\end{equation}
	\indent\textbf{-} {\textbf{分量形式}}:
	\begin{equation}
		x_i^{(k+1)} = \frac{1}{a_{ii}} \left( b_i - \sum_{j < i} a_{ij}x_j^{(k+1)} - \sum_{j > i} a_{ij}x_j^{(k)} \right), \quad i=1, 2, \dots, n
	\end{equation}
	
	\noindent{\heiti 收敛性}
	
	\indent\textbf{-} {\textbf{充要条件}}: 迭代法收敛的充要条件是迭代矩阵的谱半径小于1。对于雅可比法，即 $\rho(\mathbf{B}_{GS}) < 1$，其中 $\mathbf{B}_{GS} = -(\mathbf{D} + \mathbf{L})^{-1}\mathbf{U}$。 \\
	\indent\textbf{-} {\textbf{充分条件}}: 如果系数矩阵 A 是严格对角占优矩阵，则高斯-赛德尔迭代法必定收敛。\\
	\indent\textbf{-} {\textbf{充分条件}}: 如果系数矩阵 A 是对角占优矩阵且不可约，高斯-赛德尔迭代法必定收敛。\\
	\indent\textbf{-} {\textbf{充分条件}}: 如果迭代矩阵 $\mathbf{B}_{GS}$ 的范数小于1高斯-赛德尔迭代法必定收敛。\\
	\indent\textbf{-} {\textbf{充分条件}}: 如果系数矩阵 $\mathbf{A}$ 是对称正定矩阵，则高斯-赛德尔迭代法必定收敛。
	
	\vspace{0.5em}
	\noindent{\heiti 程序运行截图}
	
	下图为程序利用高斯-赛德尔迭代法求解线性方程组时的截图，详细代码见附录C。
	
	\begin{figure}[h] % 'h'ere, 't'op, 'b'ottom, 'p'age of floats
		\centering % 整体居中
		
		% --- 第一行图片 ---
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/gssdr (1).png}
		\end{subfigure}
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/gssdr (2).png}
		\end{subfigure}
		
		
		% --- 第二行图片 ---
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/gssdr (3).png}
		\end{subfigure}
		\begin{subfigure}[b]{0.4\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/gssdr (4).png}
		\end{subfigure}
		
		\caption{高斯-赛德尔迭代法程序运行截图}
		\label{fig:gssde}
	\end{figure}
	
	\subsubsection{松弛迭代法}
	
	\noindent{\heiti 介绍}
	
	松弛迭代法是高斯-赛德尔法的一种改进。它在计算出高斯-赛德尔迭代值后将其与上一次的旧值进行加权平均作为新值。
	
	\vspace{0.5em}
	\noindent{\heiti 矩阵迭代公式}

	\indent\textbf{-} {\textbf{分量形式}}: 设 $\tilde{x}_i^{(k+1)}$ 为高斯-赛德尔法计算出的中间值，则
	\begin{equation}
		\begin{aligned}
			\tilde{x}i^{(k+1)} &= \frac{1}{a{ii}} \left( b_i - \sum_{j < i} a_{ij}x_j^{(k+1)} - \sum_{j > i} a_{ij}x_j^{(k)} \right) \\
			x_i^{(k+1)} &= (1-\omega)x_i^{(k)} + \omega \tilde{x}_i^{(k+1)}
		\end{aligned}
	\end{equation}
	
	\noindent{\heiti 收敛性}
	
	\textbf{-} {\textbf{必要条件}}: SOR方法收敛的一个必要条件是松弛因子 $\omega$ 必须在 $(0, 2)$ 的范围内。\\
	\indent\indent\textbf{-} {\textbf{分类}}: \\
	\indent\indent\indent\textbf{-} 当 $0 < \omega < 1$ 时，称为 \textbf{低松弛法}。\\
	\indent\indent\indent\textbf{-} 当 $\omega = 1$ 时，SOR方法为 \textbf{高斯-赛德尔法}。\\
	\indent\indent\indent\textbf{-} 当 $1 < \omega < 2$ 时，称为 \textbf{超松弛法}，用于加速收敛。
	
	\vspace{0.5em}
	\noindent{\heiti 程序运行截图}
	
	下图为程序在利用松弛迭代法求解线性方程组时的截图，详细代码见附录C。
	
	\begin{figure}[h] % 'h'ere, 't'op, 'b'ottom, 'p'age of floats
		\centering % 整体居中
		
		% --- 第一行图片 ---
		\begin{subfigure}[b]{0.45\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/sc (1).png}
		\end{subfigure}
		\begin{subfigure}[b]{0.45\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/sc (2).png}
		\end{subfigure}
		
		
		% --- 第二行图片 ---
		\begin{subfigure}[b]{0.45\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/sc (3).png}
		\end{subfigure}
		\begin{subfigure}[b]{0.45\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/sc (4).png}
		\end{subfigure}
		
		\caption{松弛迭代法程序运行截图}
		\label{fig:sc}
	\end{figure}
	
	

	\section{java软件实现}
	
	\subsection{总体设计}
	
	我的软件采用了模型-视图-控制器（MVC）的设计模式，下方为我的软件第一部分结构图，这种模式将主要的功能解耦，在日后较易进行进一步的扩展。
	
	
	\begin{figure}[h!] % [h!] 是图片位置选项，h 表示 here (此处)，! 表示强制执行
		\centering % 将整个 figure 环境中的内容居中
		
		% --- 第一个子图 ---
		\begin{subfigure}[b]{0.75\textwidth}
			% [b] 表示子图的垂直对齐方式 (b=bottom, t=top, c=center)
			% {0.48\textwidth} 定义了子图的宽度，这里是页面文本宽度的 48%
			% 两个子图宽度之和应小于 1.0\textwidth
			
			\centering % 将子图内的图片居中
			\includegraphics[width=\textwidth]{pic/mvc1.png} % 替换为你的图片文件名
			% [width=\textwidth] 使图片宽度等于其所在的 subfigure 的宽度 (即 0.48\textwidth)
			
			\caption{非线性方程求根模块架构} % 子图的标题
			\label{fig:sub1} % 用于在文本中引用此子图的标签
		\end{subfigure}
		\hfill % 这个命令会在两个子图之间创建一个弹性的水平空白，将它们推向两边
		
		% --- 第二个子图 ---
		\begin{subfigure}[b]{0.75\textwidth}
			\centering
			\includegraphics[width=\textwidth]{pic/mvc2.png} % 替换为你的图片文件名
			\caption{线性方程组求解模块架构}
			\label{fig:sub2}
		\end{subfigure}
		
		\caption{软件核心模块的 MVC 架构图} % 整个图片组的总标题
		\label{fig:main_label} % 用于在文本中引用整个图片组的标签
	\end{figure}
	
	\subsubsection{线性方程组求解模块}
	
	\indent\textbf{·} \textbf{模型}：\\
	\indent\indent\textbf{-} \texttt{Direct\_impl} 包：封装了直接解法，如高斯消元法 、带主元选择的高斯消元法 、克劳特法。\\
	\indent\indent\textbf{-} \texttt{Iterative\_impl} 包：封装了迭代解法，如雅可比法 、高斯-赛德尔法和松弛法。\\
	\indent\indent\textbf{-} \texttt{LinearSystemSolver} 作为统一的策略接口，\texttt{DirectSolver} 和 \texttt{IterativeSolver} 是其子接口，分别定义了直接法和迭代法的行为。\\
	\indent\indent\textbf{-} \texttt{MatrixState}, \texttt{VectorIterationState} 等类用于封装计算的中间状态和最终解。\\
	
	\indent\textbf{·} \textbf{视图}：\\
	\indent\indent\textbf{-} \texttt{MatrixView}：用于输入和显示系数矩阵 A 和向量 b。\\
	\indent\indent\textbf{-} \texttt{ConvergencePlot}：用于可视化展示迭代法的收敛过程。\\
	
	\indent\textbf{·} \textbf{控制器}：\\
	\indent\indent\textbf{-} \texttt{LinearSystemController}：响应用户的算法选择和“求解”命令，创建对应的求解器策略实例，执行求解过程，并从返回的状态对象中提取数据更新到 \texttt{MatrixView} 和 \texttt{ConvergencePlot} 中。
	
	\subsubsection{非线性方程求根模块}
	
	\indent\textbf{·} \textbf{模型}：\\
	\indent\indent\textbf{-} \texttt{impl} 包：包含了所有非线性求根算法的策略实现，如牛顿法 、简化牛顿法 、各种割线法、简单迭代法和艾特肯加速法。\\
	\indent\indent\textbf{-} \texttt{IterativeMethod} 是所有这些算法共同实现的策略接口。\\
	\indent\indent\textbf{-} \texttt{MethodIterator} 是迭代器实现，它持有一个 \texttt{IterativeMethod} 策略实例，并管理 \texttt{IterationState}。\\
	\indent\indent\textbf{-} \texttt{Equation} 类用于封装和解析用户输入的数学表达式。\\
	
	\indent\textbf{·} \textbf{视图}：\\
	\indent\indent\textbf{-} \texttt{OneDimPlot} / \texttt{TwoDimPlot}：用于绘制函数图像，并动态地在图上标出每一次迭代的点位，使用户可以直观地看到逼近过程。\\
	
	\indent\textbf{·} \textbf{控制器}：\\
	\indent\indent\textbf{-} \texttt{MainController}：根据用户选择的算法策略，创建 \texttt{MethodIterator}。通过控制 \texttt{Iterator} 的 \texttt{next()} 方法执行单步或连续迭代，每次迭代后从 \texttt{IterationState} 读取数据，并命令 \texttt{View} 刷新绘图。
	
	
	
	\subsection{核心功能实现}
	
	软件的核心计算功能主要围绕两大模块展开：非线性方程求根和线性方程组求解。两者都采用了\textbf{策略模式}来封装具体算法，但其内部的执行和控制流程根据问题的特性有所不同。
	
	\subsubsection{非线性方程求根实现}

	\textbf{控制器驱动的迭代流程如下}：
		\begin{itemize}
			\item \textbf{初始化}: 当用户点击“开始”时，控制器首先根据用户在下拉菜单中的选择，从 \texttt{IterativeMethod} 策略数组中获取对应的算法对象。随后，它调用该策略对象的 \texttt{createIterator()} 方法，传入 \texttt{Equation} 实例和初始值，从而创建一个与具体算法绑定的 \texttt{MethodIterator} 迭代器实例。这个过程完美体现了策略模式和工厂方法的思想。
			
			\item \textbf{单步执行}: 每次用户点击“下一步”时，控制器只需调用当前迭代器实例的 \texttt{next()} 方法。该方法会执行一次完整的迭代计算，并返回一个封装了所有中间数据的 \texttt{IterationState} 对象。
			
			\item \textbf{状态更新与可视化}: 控制器接收到 \texttt{IterationState} 对象后，将其存入历史记录列表，并调用 \texttt{View} 层的相应方法（如更新日志、重绘函数图像），从而在界面上实时反馈计算的进展。当迭代器的 \texttt{hasNext()} 方法返回 \texttt{false} 时，迭代过程终止。
		\end{itemize}

		
	\subsubsection{线性方程组求解实现}
		
		该模块区分了\textbf{直接法}和\textbf{迭代法}两种求解思路。
		
		\begin{enumerate}
			\item \textbf{双策略体系}:
			控制器 (\texttt{LinearSystemController}) 内部维护了两个独立的策略：一个用于直接法 (\texttt{DirectSolver})，另一个用于迭代法 (\texttt{IterativeSolver})。控制器根据用户的选择来决定使用哪一套策略。
			
			\item \textbf{直接法}:
			当用户选择一种直接法时，其实现流程如下：
			\begin{itemize}
				\item \textbf{预处理计算}: 控制器调用所选 \texttt{DirectSolver} 策略的 \texttt{solve()} 方法。该方法会\textbf{一次性地完成所有计算步骤}，然后返回一个 \texttt{DirectSolution} 对象。
				\item \textbf{历史状态封装}: 这个 \texttt{DirectSolution} 对象内部不仅包含了最终解，还存储了一个包含所有中间步骤状态 (\texttt{MatrixState}) 的历史记录列表。
				\item \textbf{可视化}: 用户的“下一步”操作，实际上是从这个预先计算好的历史记录列表中逐个取出 \texttt{MatrixState}，并交由 \texttt{MatrixView}进行渲染。
			\end{itemize}
			
			\item \textbf{迭代法}:
			当用户选择一种迭代法时，流程与非线性模块类似，流程如下：
			\begin{itemize}
				\item \textbf{创建迭代器}: 控制器调用所选 \texttt{IterativeSolver} 策略的 \texttt{createIterator()} 方法来获取一个迭代器。特别地，对于SOR方法，控制器会额外读取用户输入的 $\omega$ 值并传入。
				\item \textbf{实时单步计算}: 用户的“下一步”操作会调用迭代器的 \texttt{next()} 方法，\textbf{实时执行一次迭代计算}，并返回一个包含当前步结果 (\texttt{VectorIterationState}) 的状态对象。
				\item \textbf{可视化}: 控制器将新的状态对象传递给 \texttt{ConvergencePlot}，后者会在收敛图中\textbf{增量地添加}一个新的数据点，实时描绘解的收敛轨迹。
			\end{itemize}
		\end{enumerate}

	
	\subsubsection{函数字符串识别与函数求值}
	
	相关的代码我附在附录D处，下面介绍我所用到的算法与逻辑。
	
	\begin{enumerate}
	
	\item \textbf{词法分析} 
	
		这里我们在所有的运算符、括号和逗号前后添加空格，然后基于空格进行分割，得到初步的符号流，例如 \texttt{[ "-", "x", "*", "sin", "(", "pi", "*", ")" ]}。
	
	\item \textbf{调度场算法}
	这里我们利用调度长算法将中缀表达式的符号流转换为后缀表达式，即\textbf{逆波兰表达式 (RPN)}。\\
	我们严格遵守调度场算法的相关要求，设置辅助栈来协助转换字符串，高优先级先压栈，低优先级则出栈加入输出队列（实际情况更加复杂，此处我自己实现了普通的调度场算法，更多的细致内容如特殊函数、左右结合的处理由AI辅助完成）。
	
	
	我们
	
	\item \textbf{求值}
	这里我们使用一个栈来进行函数求值。首先我们遍历 RPN 列表：遇到数字、常数或变量值，则压入栈中；遇到运算符或函数，则从栈中弹出所需数量的操作数，进行计算，并将结果压回栈中。遍历结束后，栈中唯一剩下的元素即为表达式的最终计算结果。
	\end{enumerate}
	
	\newpage
	\subsection{软件界面介绍}
	
	下图展示了软件中方程迭代法子功能的用户界面。可以看到整个界面分为三部分：上侧为用户输入区，在这里用户输入自己想求解的方程、选择想使用的迭代方法，并重置或单步运行迭代；左下方为可视化区域，在这里用户可以看到二维平面和一维数轴上迭代点的变化；右下侧为迭代日志，在这里用户可以看到每一次迭代的详细信息。
	
	\begin{figure}[h!]
		\centering 
		\includegraphics[width=0.6\textwidth]{pic/jm (1).png} 
		\caption{方程的迭代法用户界面} % 图片的标题
	\end{figure}
	
	下图展示了线性方程组直接法软件的用户界面。可以看到这个页面被分成了上中下三个部分，上部为矩阵输入处，用于用户输入要进行求解的增广矩阵；中间部分为程序求解过程的可视化处，在这里用户可以看到矩阵是如何一步步变化为最终答案的；最下侧展现了每一次迭代过程的详细操作和记录。
	
	\begin{figure}[h!]
		\centering 
		\includegraphics[width=0.6\textwidth]{pic/jm (3).png} 
		\caption{线性方程组直接法软件用户界面} % 图片的标题
	\end{figure}
	
	\newpage
	
	下图展示了线性方程组迭代法软件的用户界面。同样的这个图被分为了三个部分，在上侧依旧是矩阵输入处用于输入要求解的矩阵；中间展示每一次迭代产生的向量与答案向量之间范数的大小用于衡量误差大小；最下侧记录迭代过程中的相关数据。
	
	\begin{figure}[h!]
		\centering 
		\includegraphics[width=0.6\textwidth]{pic/jm (2).png} 
		\caption{线性方程组迭代法软件用户界面} % 图片的标题
	\end{figure}
	
	\newpage
	
	\section{总结}
	
	\subsection{工作总结}
	
	总的来说本报告较为详细的分析与展示了不同算法各自的数学原理和收敛性分析。就迭代法本质来看，所有相关迭代方法均是由最初的普通迭代法改造而来（无论是方程还是方程组），其本质无外乎修改映射方式使映射的收缩效果更好来加快收敛速度。
	
	此外，本报告还提供了一款基于java开发的可视化软件，并以此来详细的展示多种方法不同的运行模式。本软件采用了MVC布局，便于日后的拓展任务。
	
	通过将抽象的公式转化为直观的动画和图，本报告连接了编程实践和理论学习，一定程度上减轻了数值分析的学习任务，达到了预期的目标。
	
	最后，本人建议您可以从GitHub（\url{https://github.com/twx145/Numerical-Analysis/releases/tag/v2.5.0}）上下载最新软件。
	
	\subsection{展望}
	
	为了进一步提升本软件的广度和深度，未来可以从以下几部分展开研究
	
	\begin{itemize}
		\item \textbf{扩充算法库}:
		集成更多高级算法，如处理多项式根的拉盖尔法。
		
		\item \textbf{增强交互与智能}:
		开发如拖拽初始点、用户缩放图像等功能，使探索分析过程更加便捷、智能。
	\end{itemize}
	
	
	% ======================================================================
	% 5. 参考文献
	% ======================================================================
	\newpage
	% --- 设置正文部分的页码为阿拉伯数字, 并从1开始 ---
	\pagenumbering{arabic}
	\begin{center}
		{\Large\bfseries\sffamily 参考文献}
	\end{center}
	\printbibliography[heading=none]
	\markboth{参考文献}{}
	
	
	
	% ======================================================================
	% 6. 致谢 (可选)
	% ======================================================================
	\newpage
	\begin{center}
		{\Large\bfseries\sffamily 致谢}
	\end{center}
	
	\addcontentsline{toc}{section}{致谢} % 将致谢添加到目录中
	\markboth{致谢}{}
	
	衷心感谢孙新老师在《数值分析》课程中的指导与帮助！报告不足之处，恳请指正。
	
	
	% ======================================================================
	% 7. 附录 (可选)
	% ======================================================================
	\newpage
	\appendix
	\begin{center}
		{\Large\bfseries\sffamily 附录}
	\end{center}
	\addcontentsline{toc}{section}{附录}
	\markboth{附录}{}
	
	
	\section{方程的迭代解法完整代码}
	\markboth{附录}{}
	
	\subsubsection*{普通迭代法}
	
	\begin{lstlisting}[language=Java, caption={普通迭代法单步迭代核心逻辑}, label={lst:normal-java}]
		if (k == 0) {
			double fx0 = equation.getF().apply(x_curr);
			IterationState initialState = IterationState.initial(x_curr, fx0);
			x_prev = x_curr;
			k++;
			return initialState;
		}
		// --- 执行一次普通迭代 ---
		x_curr = equation.getG().apply(x_prev);
	\end{lstlisting}
	
	\subsubsection*{牛顿迭代法}
	
	\begin{lstlisting}[language=Java, caption={牛顿迭代法单步迭代核心逻辑}, label={lst:newton-java}]
		if (k == 0) {
			double fx0 = equation.getF().apply(x_curr);
			IterationState initialState = IterationState.initial(x_curr, fx0);
			x_prev = x_curr;
			k++;
			return initialState;
		}
		// --- 执行一次牛顿法迭代 ---
		double fx = equation.getF().apply(x_prev);
		double dfx = equation.getDf().apply(x_prev);
		
		if (Math.abs(dfx) < 1e-12) {
			x_curr = Double.NaN;
		} else {
			x_curr = x_prev - fx / dfx;
		}
	\end{lstlisting}
	
	\subsubsection*{简化切线法}
	
	\begin{lstlisting}[language=Java, caption={简化切线法单步迭代核心逻辑}, label={lst:SimplifiedNewton-java}]
		if (k == 0) {
			double fx0 = equation.getF().apply(x_curr);
			IterationState initialState = IterationState.initial(x_curr, fx0);
			x_prev = x_curr;
			k++;
			return initialState;
		}
		// --- 执行一次简化切线法迭代 ---
		x_curr = x_prev - equation.getF().apply(x_prev) / dfx0;
	\end{lstlisting}
	
	\subsubsection*{修正切线法}
	
	\begin{lstlisting}[language=Java, caption={修正切线法单步迭代核心逻辑}, label={lst:modified-java}]
		if (k == 0) {
			double fx0 = equation.getF().apply(x_curr);
			IterationState initialState = IterationState.initial(x_curr, fx0);
			x_prev = x_curr;
			k++;
			return initialState;
		}
		
		double fx = equation.getF().apply(x_prev);
		
		if (k == 1 || (k - 1) % this.updateInterval == 0) {
			this.derivative_approx = (equation.getF().apply(x_prev + H) - fx) / H;
		}
		// --- 执行一次修正切线法迭代 ---
		if (Math.abs(this.derivative_approx) < 1e-12) {
			x_curr = Double.NaN;
		} else {
			x_curr = x_prev - fx / this.derivative_approx;
		}
	\end{lstlisting}
	
	\newpage
	
	\subsubsection*{单点弦截法}
	
	
	\begin{lstlisting}[language=Java, caption={单点弦截法单步迭代核心逻辑}, label={lst:single-java}]
		if (k == 1) {
			double error_abs = Math.abs(x_curr - x_prev);
			IterationState firstState = new IterationState(k, x_curr, x_prev, equation.getF().apply(x_curr), error_abs, Double.NaN);
			x_prev_prev = x_prev;
			x_prev = x_curr;k++;
			return firstState;
		}
		// --- 执行一次单点割线法迭代 ---
		double fx_prev = equation.getF().apply(x_prev);
		double denominator = fx_prev - fx_fixed;
		
		if (Math.abs(denominator) < 1e-12) {
			x_curr = Double.NaN; 
		} else {
			x_curr = x_prev - fx_prev * (x_prev - x_fixed) / denominator;
		}
	\end{lstlisting}
	
	\subsubsection*{艾特肯迭代法}
	
	\begin{lstlisting}[language=Java, caption={艾特肯迭代法单步迭代核心逻辑}, label={lst:aitken-java}]
		if (k == 0) {
			double fx0 = equation.getF().apply(x_curr);
			IterationState initialState = IterationState.initial(x_curr, fx0);
			x_prev = x_curr; 
			k++;
			return initialState;
		}
		// --- 执行一次艾特肯加速迭代 ---
		double x0_k = x_prev;
		double x1_k = g.apply(x0_k);
		double x2_k = g.apply(x1_k);		
		double denominator = x2_k - 2 * x1_k + x0_k;
		if (Math.abs(denominator) < 1e-12) {
			x_curr = Double.NaN; 
		} else {
			x_curr = x0_k - Math.pow(x1_k - x0_k, 2) / denominator;
		}
	\end{lstlisting}
	
	
	\subsubsection*{牛顿下山法}
	
	\begin{lstlisting}[language=Java, caption={牛顿下山法单步迭代核心逻辑}, label={lst:dampedNewton-java}]
		if (k == 0) {
			double fx0 = equation.getF().apply(x_curr);
			IterationState initialState = IterationState.initial(x_curr, fx0);
			x_prev = x_curr;
			k++;
			return initialState;
		}
		
		// --- 执行一次下山法迭代 ---
		double fx_prev = equation.getF().apply(x_prev);
		double dfx_prev = equation.getDf().apply(x_prev);
		
		if (Math.abs(dfx_prev) < 1e-12) {
			x_curr = Double.NaN; 
		} else {
			double lambda = 1.0;
			int maxTries = 10;
			boolean found = false;
			while (maxTries-- > 0) {
				double x_next_candidate = x_prev - lambda * (fx_prev / dfx_prev);
				if (Math.abs(equation.getF().apply(x_next_candidate)) < Math.abs(fx_prev)) {
					x_curr = x_next_candidate;
					found = true;
					break;
				}
				lambda /= 2.0;
			}
			if (!found) {
				x_curr = Double.NaN; 
			}
		}
	\end{lstlisting}
	
	\newpage
	\subsubsection*{双点弦截法}
	
	\begin{lstlisting}[language=Java, caption={双点弦截法单步迭代核心逻辑}, label={lst:double-java}]
		if (k == 0) {
			k++;
			return IterationState.initial(x_old, equation.getF().apply(x_old));
		}
		if (k == 1) {
			double error_abs = Math.abs(x_curr - x_old);
			IterationState state = new IterationState(k, x_curr, x_old, equation.getF().apply(x_curr), error_abs, Double.NaN);
			x_older = x_old;
			x_old = x_curr;
			k++;
			return state;
		}
		// --- 执行一次双点割线法迭代 ---
		double fx_old = equation.getF().apply(x_old);
		double fx_older = equation.getF().apply(x_older);
		double denominator = fx_old - fx_older;
		
		if (Math.abs(denominator) < 1e-12) {
			x_curr = Double.NaN;
		} else {
			x_curr = x_old - fx_old * (x_old - x_older) / denominator;
		}
	\end{lstlisting}
	
	
	\newpage
	\section{线性方程组的直接解法完整代码}
	\markboth{附录}{}
	
	\subsubsection*{克劳特消元法}
	
	\begin{lstlisting}[language=Java, caption={克劳特消元法核心逻辑}, label={lst:dampedNewton-java}]
		// 消元
		for (int i = 0; i < n; i++) {
			double pivot = aug.getEntry(i, i);
			if (Math.abs(pivot) < EPSILON) {
				history.add(new MatrixState("错误: 主元 A(" + (i + 1) + "," + (i + 1) + ") 为零或过小，无法继续", aug.copy(), new int[]{i}));
				return new DirectSolution(history, null); 
			}
			
			// a. 归一化当前行，使主元变为1
			if (Math.abs(pivot - 1.0) > EPSILON) { 
				aug.setRowVector(i, aug.getRowVector(i).mapDivide(pivot));
				String desc = String.format("归一化: R%d = R%d / %.3f", i + 1, i + 1, pivot);
				history.add(new MatrixState(desc, aug.copy(), new int[]{i}));
			}
			
			// b. 对当前主元下方的所有行进行消元
			for (int j = i + 1; j < n; j++) {
				double factor = aug.getEntry(j, i); 
				if (Math.abs(factor) < EPSILON) continue; 
				
				// 执行行变换: Rj = Rj - factor * Ri
				RealVector rowI = aug.getRowVector(i).mapMultiply(factor);
				RealVector rowJ = aug.getRowVector(j).subtract(rowI);
				aug.setRowVector(j, rowJ);
				
				String desc = String.format("行变换: R%d = R%d - (%.3f) * R%d", j + 1, j + 1, factor, i + 1);
				history.add(new MatrixState(desc, aug.copy(), new int[]{i, j}));
			}
		}
		history.add(new MatrixState("前向消元完成，形成主对角线为1的上三角矩阵", aug.copy(), null));		
	\end{lstlisting}
	
	
	
	\newpage
	
	
	\subsubsection*{高斯列主元素消元法}
	
	\begin{lstlisting}[language=Java, caption={高斯列主元素消元法核心逻辑}, label={lst:dampedNewton-java}]
		// 消元
		for (int i = 0; i < n; i++) {
			int max = i;
			for (int j = i + 1; j < n; j++) {
				if (Math.abs(aug.getEntry(j, i)) > Math.abs(aug.getEntry(max, i))) {
					max = j;
				}
			}
			if (i != max) {
				double[] temp = aug.getRow(i);
				aug.setRow(i, aug.getRow(max));
				aug.setRow(max, temp);
				history.add(new MatrixState("行交换: R" + (i + 1) + " <-> R" + (max + 1), aug.copy(), new int[]{i, max}));
			}
			if (Math.abs(aug.getEntry(i, i)) < EPSILON) {
				history.add(new MatrixState("错误: 主元过小, 矩阵奇异或接近奇异", aug.copy(), new int[]{i}));
				return new DirectSolution(history, null);
			}
			for (int j = i + 1; j < n; j++) {
				double factor = aug.getEntry(j, i) / aug.getEntry(i, i);
				if (Math.abs(factor) < EPSILON) continue;
				RealVector rowI = aug.getRowVector(i).mapMultiply(factor);
				RealVector rowJ = aug.getRowVector(j).subtract(rowI);
				aug.setRowVector(j, rowJ);
				String desc = String.format("行变换: R%d = R%d - (%.3f) * R%d", j + 1, j + 1, factor, i + 1);
				history.add(new MatrixState(desc, aug.copy(), new int[]{i, j}));
			}
		}
		history.add(new MatrixState("前向消元完成，形成上三角矩阵", aug.copy(), null));
	\end{lstlisting}
	
	
	\newpage
	
	
	\subsubsection*{高斯全主元素消元法}
	
	\begin{lstlisting}[language=Java, caption={高斯全主元素消元法核心逻辑}, label={lst:dampedNewton-java}]
		// 消元 
		for (int i = 0; i < n; i++) {
			int pivotRow = i;
			int pivotCol = i;
			double maxVal = Math.abs(aug.getEntry(i, i));
			
			for (int row = i; row < n; row++) {
				for (int col = i; col < n; col++) {
					if (Math.abs(aug.getEntry(row, col)) > maxVal) {
						maxVal = Math.abs(aug.getEntry(row, col));
						pivotRow = row;
						pivotCol = col;
					}
				}
			}
			// --- 行交换 ---
			if (i != pivotRow) {
				double[] temp = aug.getRow(i);
				aug.setRow(i, aug.getRow(pivotRow));
				aug.setRow(pivotRow, temp);
				history.add(new MatrixState("行交换: R" + (i + 1) + " <-> R" + (pivotRow + 1), aug.copy(), new int[]{i, pivotRow}));
			}
			// --- 列交换 ---
			if (i != pivotCol) {
				RealVector temp = aug.getColumnVector(i);
				aug.setColumnVector(i, aug.getColumnVector(pivotCol));
				aug.setColumnVector(pivotCol, temp);
				
				int tempIndex = colIndices[i];
				colIndices[i] = colIndices[pivotCol];
				colIndices[pivotCol] = tempIndex;
				
				history.add(new MatrixState("列交换: C" + (i + 1) + " <-> C" + (pivotCol + 1) +
				", 新列顺序: " + Arrays.toString(colIndices), aug.copy(), null));
			}
			
			if (Math.abs(aug.getEntry(i, i)) < EPSILON) {
				history.add(new MatrixState("错误: 主元过小, 矩阵奇异或接近奇异", aug.copy(), new int[]{i}));
				return new DirectSolution(history, null);
			}
			// 消元
			for (int j = i + 1; j < n; j++) {
				double factor = aug.getEntry(j, i) / aug.getEntry(i, i);
				if (Math.abs(factor) < EPSILON) continue;
				RealVector rowI = aug.getRowVector(i).mapMultiply(factor);
				RealVector rowJ = aug.getRowVector(j).subtract(rowI);
				aug.setRowVector(j, rowJ);
				String desc = String.format("行变换: R%d = R%d - (%.3f) * R%d", j + 1, j + 1, factor, i + 1);
				history.add(new MatrixState(desc, aug.copy(), new int[]{i, j}));
			}
		}
		history.add(new MatrixState("前向消元完成，形成上三角矩阵", aug.copy(), null));
	\end{lstlisting}
	
	\subsubsection*{高斯消元法}
	
	\begin{lstlisting}[language=Java, caption={高斯消元法核心逻辑}, label={lst:dampedNewton-java}]
		// 消元
		for (int i = 0; i < n; i++) {
			if (Math.abs(aug.getEntry(i, i)) < EPSILON) {
				history.add(new MatrixState("错误: 主元 A(" + (i + 1) + "," + (i + 1) + ") 为零或过小，无法继续", aug.copy(), new int[]{i}));
				return new DirectSolution(history, null); 
			}
			for (int j = i + 1; j < n; j++) {
				double factor = aug.getEntry(j, i) / aug.getEntry(i, i);
				if (Math.abs(factor) < EPSILON) continue; 
				RealVector rowI = aug.getRowVector(i).mapMultiply(factor);
				RealVector rowJ = aug.getRowVector(j).subtract(rowI);
				aug.setRowVector(j, rowJ);
				String desc = String.format("行变换: R%d = R%d - (%.3f) * R%d", j + 1, j + 1, factor, i + 1);
				history.add(new MatrixState(desc, aug.copy(), new int[]{i, j}));
			}
		}
		history.add(new MatrixState("前向消元完成，形成上三角矩阵", aug.copy(), null));
	\end{lstlisting}
	
	
	\newpage
	\section{线性方程组的迭代解法完整代码}
	\markboth{附录}{}
	
	
	\subsubsection*{雅可比迭代法}
	
	\begin{lstlisting}[language=Java, caption={雅可比迭代法核心逻辑}, label={lst:dampedNewton-java}]
		@Override
		public VectorIterationState next() {
			if (k == 0) {
				k++;
				return new VectorIterationState(0, x0.copy(), residualNorm);
			}
			
			RealVector x_new = new ArrayRealVector(x.getDimension());
			for (int i = 0; i < a.getRowDimension(); i++) {
				double sigma = 0;
				for (int j = 0; j < a.getColumnDimension(); j++) {
					if (i != j) {
						sigma += a.getEntry(i, j) * x.getEntry(j);
					}
				}
				x_new.setEntry(i, (b.getEntry(i) - sigma) / a.getEntry(i, i));
			}
			x = x_new;
			residualNorm = a.operate(x).subtract(b).getNorm();
			return new VectorIterationState(k++, x.copy(), residualNorm);
		}
	\end{lstlisting}
	
	\newpage
	
	\subsubsection*{高斯-赛德尔迭代法}
	
	\begin{lstlisting}[language=Java, caption={高斯-赛德尔迭代法核心逻辑}, label={lst:dampedNewton-java}]
		@Override
		public VectorIterationState next() {
			if (k == 0) {
				k++;
				return new VectorIterationState(0, x0.copy(), residualNorm);
			}
			
			RealVector x_new = x.copy();
			for (int i = 0; i < a.getRowDimension(); i++) {
				double sigma1 = 0;
				for (int j = 0; j < i; j++) {
					sigma1 += a.getEntry(i, j) * x_new.getEntry(j);
				}
				
				double sigma2 = 0;
				for (int j = i + 1; j < a.getColumnDimension(); j++) {
					sigma2 += a.getEntry(i, j) * x.getEntry(j);
				}
				
				x_new.setEntry(i, (b.getEntry(i) - sigma1 - sigma2) / a.getEntry(i, i));
			}
			
			x = x_new;
			residualNorm = a.operate(x).subtract(b).getNorm();
			
			return new VectorIterationState(k++, x.copy(), residualNorm);
		}
	\end{lstlisting}
	
	\newpage
	
	\subsubsection*{松弛迭代法}
	
	\begin{lstlisting}[language=Java, caption={松弛迭代法核心逻辑}, label={lst:dampedNewton-java}]
		@Override
		public VectorIterationState next() {
			if (k == 0) {
				k++;
				return new VectorIterationState(0, x0.copy(), residualNorm);
			}
			
			RealVector x_old = x.copy();
			
			for (int i = 0; i < a.getRowDimension(); i++) {
				double sigma1 = 0; 
				for (int j = 0; j < i; j++) {
					sigma1 += a.getEntry(i, j) * x.getEntry(j);
				}
				
				double sigma2 = 0; 
				for (int j = i + 1; j < a.getColumnDimension(); j++) {
					sigma2 += a.getEntry(i, j) * x_old.getEntry(j);
				}
				
				double gs_component = (b.getEntry(i) - sigma1 - sigma2) / a.getEntry(i, i);
				
				double new_xi = (1 - omega) * x_old.getEntry(i) + omega * gs_component;
				x.setEntry(i, new_xi);
			}
			
			residualNorm = a.operate(x).subtract(b).getNorm();
			return new VectorIterationState(k++, x.copy(), residualNorm);
		}
	\end{lstlisting}
	
	\newpage
	\section{函数识别与求值部分完整代码}
	\markboth{附录}{}
	
	\begin{lstlisting}[language=Java, caption={函数识别核心逻辑}, label={lst:dampedNewton-java}]
		public class Equation {
			
			private final ManualExpression f, g;
			private static final double H = 1e-7; 
			
			public Equation(String fStr, String gStr) {
				this.f = new ManualExpression(fStr);
				if (gStr != null && !gStr.isBlank()) {
					this.g = new ManualExpression(gStr);
				} else {
					this.g = new ManualExpression(null); 
				}
			}
			
			public Function<Double, Double> getF() {
				return f::evaluate;
			}
			
			public Function<Double, Double> getG() {
				return g::evaluate;
			}
			public Function<Double, Double> getDf() {
				
				return (x) -> {
					try {
						double f_x_plus_h = f.evaluate(x + H);
						double f_x_minus_h = f.evaluate(x - H);
						return (f_x_plus_h - f_x_minus_h) / (2 * H);
					} catch (Exception e) {
						return Double.NaN;
					}
				};
			}
		}
	\end{lstlisting}
	
	\newpage
	
	\begin{lstlisting}[language=Java, caption={词法分析}, label={lst:dampedNewton-java}]
		private List<String> tokenize(String expression) {
			List<String> tokens = new ArrayList<>();
			
			expression = expression.replace("(", " ( ");
			expression = expression.replace(")", " ) ");
			expression = expression.replace(",", " , ");
			for (String op : PRECEDENCE.keySet()) {
				if (!op.equals(UNARY_MINUS)) { 
					expression = expression.replace(op, " " + op + " ");
				}
			}
			
			String[] rawTokens = expression.trim().split("\\s+");
			Collections.addAll(tokens, rawTokens);
			
			return tokens;
		}
	\end{lstlisting}
	
	\begin{lstlisting}[language=Java, caption={调度场算法}, label={lst:dampedNewton-java}]
		private List<String> shuntingYard(List<String> tokens) {
			List<String> outputQueue = new ArrayList<>();
			Stack<String> operatorStack = new Stack<>();
			String lastToken = null;
			for (String token : tokens) {
				if (isNumber(token) || CONSTANTS.containsKey(token.toLowerCase())) {
					outputQueue.add(token);
				} else if (isVariable(token)) {
					outputQueue.add(token);
				} else if (FUNCTIONS.containsKey(token.toLowerCase())) {
					operatorStack.push(token);
				} else if (token.equals(",")) {
					while (!operatorStack.isEmpty() && !operatorStack.peek().equals("(")) {
						outputQueue.add(operatorStack.pop());}
					if (operatorStack.isEmpty()) {
						throw new IllegalArgumentException("非法输入: 逗号位置不当或括号不匹配。");}
				} else if (token.equals("-") && (lastToken == null || PRECEDENCE.containsKey(lastToken) || lastToken.equals("("))) {
					operatorStack.push(UNARY_MINUS);
				} else if (PRECEDENCE.containsKey(token)) { 
					while (!operatorStack.isEmpty() && PRECEDENCE.containsKey(operatorStack.peek())) {
						String op2 = operatorStack.peek();
						if ((ASSOCIATIVITY.get(token) && PRECEDENCE.get(token) <= PRECEDENCE.get(op2)) ||
						(!ASSOCIATIVITY.get(token) && PRECEDENCE.get(token) < PRECEDENCE.get(op2))) {
							outputQueue.add(operatorStack.pop());
						} else {
							break;}}
					operatorStack.push(token);
				} else if (token.equals("(")) {
					operatorStack.push(token);
				} else if (token.equals(")")) {
					while (!operatorStack.isEmpty() && !operatorStack.peek().equals("(")) {
						outputQueue.add(operatorStack.pop());}
					if (operatorStack.isEmpty()) {
						throw new IllegalArgumentException("非法输入: 括号不匹配。");}
					operatorStack.pop(); 
					if (!operatorStack.isEmpty() && FUNCTIONS.containsKey(operatorStack.peek().toLowerCase())) {
						outputQueue.add(operatorStack.pop());}
				} else {
					throw new IllegalArgumentException("非法输入: 包含无法识别的符号 '" + token + "'");}
				lastToken = token;}
			while (!operatorStack.isEmpty()) {
				String op = operatorStack.pop();
				if (op.equals("(")) {
					throw new IllegalArgumentException("非法输入: 括号不匹配。");}
				outputQueue.add(op);}
			return outputQueue;
		}
	\end{lstlisting}
	
	\newpage
	\begin{lstlisting}[language=Java, caption={函数求值}, label={lst:dampedNewton-java}]
		public double evaluate(double xValue) {
			if (variables.size() > 1 || (variables.size() == 1 && !variables.contains("x"))) {
				throw new IllegalArgumentException("该表达式需要 'x' 之外的变量，无法仅用 xValue 求值。");}
			Stack<Double> valueStack = new Stack<>();
			for (String token : rpnExpression) {
				if (isNumber(token)) {
					valueStack.push(Double.parseDouble(token));
				} else if (CONSTANTS.containsKey(token.toLowerCase())) {
					valueStack.push(CONSTANTS.get(token.toLowerCase()));
				} else if (token.equalsIgnoreCase("x")) {
					valueStack.push(xValue);
				} else if (PRECEDENCE.containsKey(token)) {
					if (token.equals(UNARY_MINUS)) {
						if (valueStack.isEmpty()) throw new IllegalArgumentException("非法输入: 运算符缺少操作数。");
						valueStack.push(-valueStack.pop());
					} else {
						if (valueStack.size() < 2) throw new IllegalArgumentException("非法输入: 运算符缺少操作数。");
						double b = valueStack.pop();
						double a = valueStack.pop();
						valueStack.push(applyOperator(token, a, b));}
				} else if (FUNCTIONS.containsKey(token.toLowerCase())) {
					String func = token.toLowerCase();
					int numArgs = FUNCTIONS.get(func);
					if (valueStack.size() < numArgs) {
						throw new IllegalArgumentException("非法输入: 函数 '" + func + "' 的参数数量不足。");}
					List<Double> args = new ArrayList<>();
					for (int i = 0; i < numArgs; i++) {
						args.add(valueStack.pop());}
					Collections.reverse(args); 
					valueStack.push(applyFunction(func, args));}}
			if (valueStack.size() != 1) {
				throw new IllegalArgumentException("非法输入: 表达式格式错误，导致最终栈中元素不唯一。");}
			return valueStack.pop();
		}
	\end{lstlisting}
	
\end{document}